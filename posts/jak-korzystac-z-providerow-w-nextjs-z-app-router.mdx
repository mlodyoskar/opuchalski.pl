---
title: 'Jak korzystaÄ‡ z ProviderÃ³w w Next.js z App Router'
description: Wraz z nowym podejÅ›ciem w App Router zmienia siÄ™ sposÃ³b w jaki uÅ¼ywamy ProviderÃ³w. Dowiedz siÄ™ jak to zrobiÄ‡.
date: '2023-05-11'
image: '/images/jak-korzystac-z-providerow-w-nextjs-z-app-router/thumbnail.png'
featured: true
---

Najnowsza wersja Next.js, obecnie 13.4, wprowadziÅ‚a stabilnÄ… i gotowÄ… do uÅ¼ycia wersjÄ™ App Routera. Jednak najwaÅ¼niejszÄ… zmianÄ… jest wprowadzenie React Server Components, ktÃ³re oferujÄ… wiele przydatnych i interesujÄ…cych funkcji, ale wymagajÄ… innego sposobu myÅ›lenia o budowaniu aplikacji.

## Czym sÄ… Providery w React?

Provider w React.js jest to komponent ktÃ³ry ma za zadanie dostarczyÄ‡ dane do komponentÃ³w podrzÄ™dnych. Realizuje siÄ™ to z wykorzystaniem hooka `useContext`.

PrzykÅ‚adowy Provider:

```tsx
const MyContext = createContext();

// Komponent dostarczajÄ…cy dane
const MyProvider = ({ children }) => {
  const name = 'John Doe';

  return <MyContext.Provider value={name}>{children}</MyContext.Provider>;
};
```

NastÄ™pnie moÅ¼emy takiego komponentu uÅ¼yÄ‡, a wszystkie komponenty bÄ™dÄ…ce dzieÄ‡mi tego Providera bÄ™dÄ… miaÅ‚y dostÄ™p do zmiennej `name` poprzez konekst.

## Jak wykorzystaÄ‡ to w App Router?

W _App Router_ wszystkie komponenty domyÅ›lnie sÄ… komponentami serwerowymi (_server components_), a w takowych nie moÅ¼emy wykorzystywaÄ‡ Å¼adnych hookÃ³w.

Z pomocÄ… przychodzi dyrektywa (mÄ…dre sÅ‚owo ğŸ™‚) _â€œuse clientâ€_, ktÃ³rej musimy uÅ¼yÄ‡, aby oznaczyÄ‡ Å¼e komponent ma zostaÄ‡ wyrenderowany na serwerze, a nastÄ™pnie po stronie klienta ma dojÅ›Ä‡ do hydracji, czyli dodania interkatywnoÅ›ci do naszej aplikacji. W naszym przypadku poprzez dodanie kontekstu.

## PrzykÅ‚ad z uÅ¼yciem React Query

_React Query_ jest bibliotekÄ… ktÃ³ra pomaga nam w zarzÄ…dzaniu asynchronicznym stanem. Aby mÃ³c jej uÅ¼yÄ‡ musimy, tak jak w przypadku wielu bibilotek, dostarczyÄ‡ kontekst do dzieci komponentu za pomocÄ… Providera.

### Jak wyglÄ…da to w Pages Router

Zobaczmy jednak najpierw dla porÃ³wnania jak wyglÄ…da to w Pages Router.

```tsx:pages/_app.tsx
import type { AppProps } from 'next/app';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

export const queryClient = new QueryClient();

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <QueryClientProvider client={queryClient}>
      <Component {...pageProps} />
    </QueryClientProvider>
  );
}

export default MyApp;
```

Do naszego specjalnego pliku o nazwie `_app.tsx` umieszczamy nasz Provider i w zasadzie tyle, od tego momentu moÅ¼emy w dowolnym komponencie podrzÄ™dnym dostaÄ‡ siÄ™ do kontekstu.

### Jak zrobiÄ‡ to w App Router

Jak moÅ¼emy wyczytaÄ‡ w dokumentacji, w nowym podejÅ›ciu nie mamy juÅ¼ specjalnych plikÃ³w `_document.js` oraz `_app.js`, a zamiast nich wykorzystujemy plik o nazwie `layout.js`. KaÅ¼dy projekt musi mieÄ‡ tzw. _Root Layout_ czyli layout ktÃ³ry znajduje siÄ™ obok pliku `page.tsx`.

DomyÅ›lnie wyglÄ…da on tak:

```tsx:app/layout.tsx
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

MoglibyÅ›my w takim razie wpaÅ›Ä‡ na pomysÅ‚ Â Å¼e zrobimy to w ten sposÃ³b:

```tsx:app/layout.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <QueryClientProvider client={queryClient}>
      <html lang="en">
        <body>{children}</body>
      </html>
    </QueryClientProvider>
  );
}
```

W konsoli szybko jednak pokaÅ¼e nam siÄ™ stos bÅ‚Ä™dÃ³w dotyczÄ…cych tego Å¼e bezpoÅ›rednio w komponencie serwerowym prÃ³bujemy uÅ¼yÄ‡ komponentu klienckiego.

MoÅ¼emy jednak to rozwiÄ…zaÄ‡ wyciÄ…gajÄ…c _Provider_ do oddzielnego pliku, ktÃ³rego oznaczymy z pomocÄ… â€œ_use client_â€.

```tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

export const TQueryClientProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  return (
    <QueryClientProvider client={queryClient}>
      {props.children}
    </QueryClientProvider>
  );
};
```

A nastÄ™pnie uÅ¼yÄ‡ go w `layout.tsx`

```tsx:app/layout.tsx
import { TQueryClientProvider } from './queryClientProvider';

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <TQueryClientProvider>
      <html lang="en">
        <body>{children}</body>
      </html>
    </TQueryClientProvider>
  );
}
```

W ten sposÃ³b moÅ¼emy dodaÄ‡ kaÅ¼dy Provider, zarÃ³wno stworzony przez nas, aby dostarczyÄ‡ dane z kontekstu jak i z dowolnej biblioteki ktÃ³ra od nas tego wymaga.

## Podsumowanie

OsobiÅ›cie jestem mega zajarany moÅ¼liwoÅ›ciami App Routera i myÅ›lÄ™ Å¼e to kwestia czasu, zanim te wszystkie nowoÅ›ci zacznÄ… byÄ‡ adoptowane w projektach komercyjnych.

Mam nadziejÄ™, Å¼e ten wpis byÅ‚ dla Ciebie pomocny! Do usÅ‚yszenia w nastÄ™pnym! ğŸ‘‹
